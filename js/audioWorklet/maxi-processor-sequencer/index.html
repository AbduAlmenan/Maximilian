<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>
    Javascript Audio Processing
  </title>
  <style type="text/css">
    .prettyprint ol.linenums>li {
      list-style-type: decimal
    }
  </style>
</head>

<body>

  <h1>Load-testing an audio worklet loaded with Maximilian</h1>
  <p id="funcs"></p>
  <p>Synth defs on the UI thread are posted to the worklet. Check out your dev console (Command+Option+J).</p>
  <p>You might need to clean the cache when you are testing your worklet processor code</p>

  <button id="playButton">Play</button>
  <button id="stopButton">Stop</button>
  <button id="plusButton">vol+</button>
  <button id="minusButton">volâ€“</button>
  <button id="synthButton">Change Synth</button>
  <button id="blobButton">Blob</button>
  <input type="checkbox" id="box" value="false">Load test<br>

  <script type="module">
    import Module from '../build/maximilian.wasmmodule.js';
    import { loadSampleToArray} from '../build/maximilian.wasmmodule.js';
    var maxiAudio = new Module.maxiAudio();
    console.log('maxiAudio Module.object: ' + Module.maxiAudio);
    console.log('maxiAudio instance in variable: ' + maxiAudio);
    console.log('maxiAudio init(): ' + maxiAudio.init());
    console.log('maxiAudio output: ' + maxiAudio.output);
    console.log('maxiAudio init: ' + maxiAudio.init);
    // console.log('maxiAudio loadSampleToArray: ' + loadSampleToArray());
    // console.log('maxiAudio resetAudio:' + maxiAudio.resetAudio());
    // console.log('maxiAudio: ' + new maxiAudio());
    // console.log('maxiAudio: ' + new maxiAudio());
    // console.log('maxiAudio: ' + Module.maxiAudio.loadSampleToArray);

    let audioContext;
    let customNode;
    let customProcessorName = 'maxi-processor';
    let workletUrl = 'maxi-processor.js';

    let fs = [
      `kc kc k scos`,
      `kc kc k`,
      `kc sss kccs skckos`,
    ];



    const SYNTH_CHANGE_MS = 50;


    class MaxiNode extends AudioWorkletNode {

      constructor(audioContext, processorName, options) {
        super(audioContext, processorName, options);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      setButtonEventHandlers();
    });

    function setButtonEventHandlers() {

      const playButton = document.getElementById('playButton');
      playButton.addEventListener("click", () => playAudio());

      const stopButton = document.getElementById('stopButton');
      stopButton.addEventListener("click", () => stopAudio());

      const plusButton = document.getElementById('plusButton');
      plusButton.addEventListener("click", () => increaseVolume());

      const minusButton = document.getElementById('minusButton');
      minusButton.addEventListener("click", () => decreaseVolume());

      const synthButton = document.getElementById('synthButton');
      synthButton.addEventListener("click", () => changeSynth());

      const blobButton = document.getElementById('blobButton');
      blobButton.addEventListener("click", () => sendFloat32NoiseBuffer());

      const checkBox = document.getElementById('box');
      checkBox.addEventListener("click", () => {
        if (audioContext.state === "suspended") playAudio();
        setInterval('changeSynth()', SYNTH_CHANGE_MS)
      });
    }

    function playAudio() {
      if (audioContext === undefined) {
        try {
          audioContext = new AudioContext();
          audioContext.audioWorklet.addModule(workletUrl).then(() => {

            // options initialize named AudioParams automatically.
            let options = {
              numberOfInputs: 1,
              numberOfOutputs: 1,
              outputChannelCount: [2]
            }
            // customNode = new MaxiNode(audioContext, customProcessorName, options);
            customNode = new AudioWorkletNode(audioContext, customProcessorName);
            customNode.onprocessorerror = event => {
              console.log(`MaxiProcessor Error detected: ` + event.data);
            }
            customNode.onprocessorstatechange = event => {
              console.log(`MaxiProcessor state change detected: ` + customNode.processorState);
            }
            customNode.port.onmessage = event => {
              console.log(`Message from processor: ` + event.data);
            }; // data from the processor.
            customNode.port.onmessageerror = event => {
              console.log(`Error message from port: ` + event.data);
            }; // error from the message port.
            customNode.connect(audioContext.destination);
          }).catch((e => console.log("Error on loading worklet: ", e)));
        } catch (err) {
          console.log("AudioWorklet not supported in this browser: ", err.message);
        }
      } else {
        if (audioContext.state !== "suspended")
          stopAudio();
        else
          audioContext.resume();
      }
    }

    function stopAudio() {
      if (customNode !== undefined) {
        audioContext.suspend();
        // customNode.disconnect(audioContext.destination);
        // customNode = undefined;
      }
    }

    function increaseVolume() {
      if (customNode !== undefined) {
        const gainParam = customNode.parameters.get('gain');
        gainParam.value += 0.01;
      }
    }

    function decreaseVolume() {
      if (customNode !== undefined) {
        const gainParam = customNode.parameters.get('gain');
        gainParam.value -= 0.01;
      }
    }


    function generateNoiseBuffer(length) {
      var float32Array = new Float32Array(length);
      for (var n = 0; n < length; n++) {
        float32Array[n] = Math.random(1);
      }
      return float32Array;
    }

    function sendNoiseBlob() {
      if (customNode !== undefined) {
        var blob = new Blob([generateNoiseBuffer(44100)], {
          type: "application/octet-stream"
        }); // TODO: Check for memory leaks // URL.revokeObjectURL() const
        workletUrl = window.URL.createObjectURL(blob);
        customNode.port.postMessage({
          audioBlob: blob,
        }); // Send JSON
      }
    }

    function sendFloat32NoiseBuffer() {
      if (customNode !== undefined) {
        var float32Array = generateNoiseBuffer(44100);
        console.log('noiseBuff: ' + float32Array);
        customNode.port.postMessage({
          audioArray: float32Array,
        });
      }
    }


    function sendFloat32Array(float32Array) {
      if (float32Array !== undefined && customNode !== undefined) {
        console.log('noiseBuff: ' + float32Array);
        customNode.port.postMessage({
          audioArray: float32Array,
        });
      }
    }




    
    function loadSampleToArrayBuffer() {

      // console.log(maxiAudio.loadSampleToArrayBuffer());

      if (audioContext !== undefined) {

        var data = [];
        samplePlayer.clear();

        //check if url is actually a base64-encoded string
        var b64 = Module.maxiTools.getBase64(url);
        if (b64) {
          //convert to arraybuffer
          //modified version of this:
          // https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js
          var ab_bytes = (b64.length / 4) * 3;
          var arrayBuffer = new ArrayBuffer(ab_bytes);

          b64 = Module.maxiTools.removePaddingFromBase64(Module.maxiTools.removePaddingFromBase64(b64));

          var bytes = parseInt((b64.length / 4) * 3, 10);

          var uarray;
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i = 0;
          var j = 0;

          uarray = new Uint8Array(arrayBuffer);

          b64 = b64.replace(/[^A-Za-z0-9\+\/\=]/g, "");

          for (i = 0; i < bytes; i += 3) {
              //get the 3 octects in 4 ascii chars
              enc1 = Module.maxiTools._keyStr.indexOf(b64.charAt(j++));
              enc2 = Module.maxiTools._keyStr.indexOf(b64.charAt(j++));
              enc3 = Module.maxiTools._keyStr.indexOf(b64.charAt(j++));
              enc4 = Module.maxiTools._keyStr.indexOf(b64.charAt(j++));

              chr1 = (enc1 << 2) | (enc2 >> 4);
              chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
              chr3 = ((enc3 & 3) << 6) | enc4;

              uarray[i] = chr1;
              if (enc3 !== 64) uarray[i + 1] = chr2;
              if (enc4 !== 64) uarray[i + 2] = chr3;
          }

          // https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata
          // Asynchronously decodes the audio file data contained in the ArrayBuffer.
          audioContext.decodeAudioData(
              arrayBuffer, // has its content-type determined by sniffing
              function (buffer) { // successCallback, argument is an AudioBuffer representing the decoded PCM audio data.
                  // source.buffer = buffer;
                  // source.loop = true;
                  // source.start(0);
                  data = buffer.getChannelData(0);

                  if (data) {
                      var myBufferData = new Module.VectorDouble();
                      // Module.vectorTools.clearVectorDbl(myBufferData);

                      for (var n = 0; n < data.length; n++) {
                          myBufferData.push_back(data[n]);
                      }

                      return myBufferData;
                      //NOTE: there is an asynchronous loading going on here
                      // samplePlayer.setSample(myBufferData /*, context.sampleRate*/ );
                  }

              },

              function (buffer) { // errorCallback
                  console.log("Error decoding source!");
              }
          );


          } else {
              // Load asynchronously
              // NOTE: This is giving me an error
              // Uncaught ReferenceError: XMLHttpRequest is not defined (index):97 MaxiProcessor Error detected: undefined
              // NOTE: followed the trail to the wasmmodule.js
              // when loading on if (typeof XMLHttpRequest !== 'undefined') {
              // throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. 
              // Use --embed-file or --preload-file in emcc on the main thread.");
              var request = new XMLHttpRequest();
              request.addEventListener("load",
                  function (evt) {
                      console.log("The transfer is complete.");
                  });
              request.open("GET", url, true);

              request.responseType = "arraybuffer";

              request.onload = function () {
                  context.decodeAudioData(
                      request.response,
                      function (buffer) {
                          // source.buffer = buffer;
                          // source.loop = true;
                          // source.start(0);
                          data = buffer.getChannelData(0);

                          if (data) {
                              var myBufferData = new Module.VectorDouble();
                              // Module.vectorTools.clearVectorDbl(myBufferData);

                              for (var n = 0; n < data.length; n++) {
                                  myBufferData.push_back(data[n]);
                              }

                              samplePlayer.setSample(myBufferData /*, context.sampleRate*/ );
                          }

                      },

                      function (buffer) {
                          console.log("Error decoding source!");
                      }
                  );
              };
              request.send();
          }

        }

    }

    function changeSynth() {
      if (customNode !== undefined) {
        let userDefinedFunction;
        if (arguments.length == 0) {
          userDefinedFunction = fs[Math.floor(Math.random() * fs.length)];
          customNode.port.postMessage({
            eval: `() => { return ${userDefinedFunction} }`
          }); // Send JSON object with eval prop for evaluation in processor
        } else {
          userDefinedFunction = arguments[0];
          customNode.port.postMessage({
            eval: `() => { return ${userDefinedFunction} }`
          }); // Send JSON object with eval prop for evaluation in processor
        }
        // DEBUG:
        console.log("Change synth: " + userDefinedFunction);
      }
    }
  </script>
</body>

</html>