<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>
    Javascript Audio Processing
  </title>

  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=js&amp;skin=sunburst">
  </script>
  <!-- show all line numbers-->
  <style type="text/css">
    .prettyprint ol.linenums>li {
      list-style-type: decimal
    }
  </style>
</head>

<body>

  <h1> Test simple tone and gain processor </h1>
  <p id="funcs"></p>
  <p>
    A simple sinewave with gain control. [You might need to clean the cache when you are testing your worklet processor
    code]
  </p>

  <button id="playButton">Play</button>
  <button id="stopButton">Stop</button>
  <button id="plusButton">+</button>
  <button id="minusButton">â€“</button>
  <pre class="prettyprint lang-js linenums:true" id="quine" style="border:4px solid #88c">

  </pre>

  <script type="text/javascript">
    let audioContext;
    let customNode;
    let customProcessorName = 'custom-processor';
    let workletUrl = 'custom-processor.js';

    class CustomAudioNode extends AudioWorkletNode {

      constructor(audioContext, processorName) {

        super(audioContext, processorName, {
          numberOfInputs: 0,
          numberOfOutputs: 1,
          outputChannelCount: [2]
        });
      }
    }

    /**
     * Initialises audio context and sets worklet processor code
     * @init
     */
    async function init() {
      if (this.audioContext === undefined) {
        this.audioContext = new AudioContext();
        await this.loadWorkletProcessorCode();
      }
    }

    /**
     * Initialises audio context and sets worklet processor code
     * @loadWorkletProcessorCode
     */
    async function loadWorkletProcessorCode() {
      if (this.audioContext !== undefined) {
        try {
          await this.audioContext.audioWorklet.addModule(this.audioWorkletUrl);
          // Custom node constructor with required parameters
          this.audioWorkletNode = new MaxiNode(this.audioContext, this.audioWorkletProcessorName);

          // All possible error event handlers subscribed
          this.audioWorkletNode.onprocessorerror = event => {
            // Errors from the processor
            console.log(`MaxiProcessor Error detected`);
          };          
          this.audioWorkletNode.port.onmessageerror = event => {
            //  error from the processor port
            console.log(`Error message from port: ` + event.data);
          };
          // State changes in the audio worklet processor
          this.audioWorkletNode.onprocessorstatechange = event => {
            console.log(`MaxiProcessor state change detected: ` +  audioWorkletNode.processorState);
          };
          // Worklet Processor message handler 
          this.audioWorkletNode.port.onmessage = event => {
            this.messageHandler(event.data);
          };
          // Connect the worklet node to the audio graph
          this.audioWorkletNode.connect(this.audioContext.destination);
          return true;
        } catch (err) {
          console.log("AudioWorklet not supported in this browser: ", err.message);
            return false;
        }
      } else {
        return false;
      }
    }

    /**
     * Subscribes button events to playback and volume control functions
     * @setButtonEventHandlers
     */
    function setButtonEventHandlers() {
      const playButton = document.getElementById('playButton');
      playButton.addEventListener("click", () => playAudio());
      const stopButton = document.getElementById('stopButton');
      stopButton.addEventListener("click", () => stopAudio());
      const plusButton = document.getElementById('plusButton');
      plusButton.addEventListener("click", () => increaseVolume());
      const minusButton = document.getElementById('minusButton');
      minusButton.addEventListener("click", () => decreaseVolume());
    }

	/**
	 * Initialises audio context and sets worklet processor code
	 * or re-starts audio playback by stopping and running the latest Audio Worklet Processor code
	 * @play
	 */
	function play() {
		if (this.audioContext !== undefined) {
			if (this.audioContext.state !== "suspended") {
				this.stop();
				return false;
			} else {
				this.audioContext.resume();
				return true;
			}
		}
	}

	/**
	 * Stops audio by disconnecting Audio None with Audio Worklet Processor code
	 * from Web Audio graph
	 * TODO: Investigate when it is best to just STOP the graph exectution
	 * @stop
	 */
	function stop() {
		if (this.audioWorkletNode !== undefined) {
			this.audioContext.suspend();
		}
	}

	function stopAndRelease() {
		if (this.audioWorkletNode !== undefined) {
			this.audioWorkletNode.disconnect(this.audioContext.destination);
			this.audioWorkletNode = undefined;
		}
	}

	function more(gain) {
		if (this.audioWorkletNode !== undefined) {
			const gainParam = this.audioWorkletNode.parameters.get(gain);
			gainParam.value += 0.5;
			console.log(gain + ": " + gainParam.value); // DEBUG
			return true;
		} else return false;
	}

	function less(gain) {
		if (this.audioWorkletNode !== undefined) {
			const gainParam = this.audioWorkletNode.parameters.get(gain);
			gainParam.value -= 0.5;
			console.log(gain + ": " + gainParam.value); // DEBUG
			return true;
		} else return false;
	}
 


  document.addEventListener("DOMContentLoaded", () => {
    setButtonEventHandlers();
  });

  </script>
</body>

</html>
